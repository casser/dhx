class dhtmlXAccordion extends dhtmlXCellTop {
    constructor(base, skin) {
        super()
        var that = this;
        var transData = window.dhx4.transDetect();
        this.conf = {
            skin: (skin || window.dhx4.skin || (typeof(dhtmlx) != "undefined" ? dhtmlx.skin : null) || window.dhx4.skinDetect("dhxacc") || "material"),
            css: "dhxacc", // css prefix for topcell mtb
            icons_path: "",
            icons_css: false,
            multi_mode: false,
            last_opened: null, // single_mode only
            on_active_id: null, // id for onActive in single_mode, inner
            on_active_click: false, // activation by click or by script
            size_changed: true,
            def_height: 90, // defult height
            // items count
            total_count: 0,
            hiden_count: 0,
            cont_w: null
        };
        // effects
        this.conf.tr = {
            prop: transData.transProp, // false if not available
            ev: transData.transEv,
            height_open: "height 0.2s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
            height_close: "height 0.18s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
            op_open: "opacity 0.16s ease-in", // cell_cont on open
            op_close: "opacity 0.2s ease-out", // cell_cont on close
            op_v_open: "1", // opacity for opened cell
            op_v_close: "0.4", // opacity for closed cell
            dnd_top: "top 0.16s" // dnd
        };
        // cells offsets
        this.ofs = {
            // working values, will generated by _applyOffsets
            m: {}, // multi_mode
            s: {},  // single_mode
            // default offset, based on skyblue
            def: {
                m: { // multi_mode
                    left: 0, // horizontal offset between parent-edge and cell for both left and right sides
                    right: 0, // cell to edge from right
                    first: 0, // top before first
                    between: 8 // vertical offset between cells for multi_mode
                },
                s: { // single_mode
                    left: 0,
                    right: 0,
                    first: 0,
                    between: -1,
                    last: 0 // last cell bottom's and bottom edge
                }
            }, // override by base (parentId), if base._ofs attr is set, used in attachComponent()
            base: {
                s: {},
                m: {}
            }, // override by skin
            skin: {
                dhx_web: {
                    s: {between: 3},
                    m: {between: 3}
                },
                dhx_terrace: {
                    m: {
                        between: 12,
                        left: 0,
                        right: 0
                    }
                },
                material: {
                    m: {
                        between: 12,
                        left: 0,
                        right: 0
                    }
                }
            }
        };
        // open/close fix
        if (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0) {
            // ie10, ie11
            this.conf.tr.height_open = this.conf.tr.height_close;
        } else {
            // ff, opera, chrome - good
            this.conf.tr.height_open = this.conf.tr.height_close;
        }
        var apiInit = null;
        if (typeof(base) == "object" && !base.tagName) {
            apiInit = {};
            for (var a in base) {
                apiInit[a] = base[a];
                base[a] = null;
            }
            base = apiInit.parent;
            apiInit.parent = null;
        }
        // init top container
        this._init(base, base._ofs);
        this._adjustCont();
        // offset fix, base override
        if (this.base._ofs != null) {
            for (var mode in this.ofs.base) {
                if (this.base._ofs[mode] != null) {
                    for (var a in this.base._ofs[mode]) {
                        this.ofs.base[mode][a] = this.base._ofs[mode][a];
                    }
                }
            }
        }
        this._applyOffsets = function () {
            // 1) default
            // 2) skin override if any
            // 3) base._ofs override if any
            for (var mode in this.ofs.def) {
                var def = this.ofs.def[mode];
                var skin = (this.ofs.skin[this.conf.skin] != null && this.ofs.skin[this.conf.skin][mode] != null ? this.ofs.skin[this.conf.skin][mode] : null);
                var base = (this.base._ofs != null ? this.base._ofs[mode] : null);
                for (var a in def) {
                    if (skin != null && skin[a] != null) {
                        this.ofs[mode][a] = skin[a];
                    } else if (base != null && base[a] != null) {
                        this.ofs[mode][a] = base[a];
                    } else {
                        this.ofs[mode][a] = def[a];
                    }
                }
            }
        }
        this._applyOffsets();
        this.t = {};
        this.addItem = function (id, text, open, height, icon) {

            // open - open/close new in 4.0, true by default, close prev item if any in single_mode
            // height - for multi_mode, new in 4.0
            // create cell
            // extend hdr
            // open/close
            // depending on mode - calculate width/height
            if (id == null) {
                id = "a" + window.dhx4.newId();
            }
            while (this.t[id] != null) {
                id = "a" + window.dhx4.newId();
            }
            var cell = new dhtmlXAccordionCell(id, this);
            cell.conf.skin = this.conf.skin;
            cell.setText(text);
            if (icon != null) {
                cell.setIcon(icon);
            }
            cell.cell._accId = id;
            cell.cell.childNodes[cell.conf.idx.hdr].onselectstart = function (e) {
                e = e || event;
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                }
                return false;
            }
            cell.cell.childNodes[cell.conf.idx.hdr].onclick = function (e) {
                e = e || event;
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                }
                if (that._dnd != null && that._dnd.ofs == true) {
                    return;
                } // dnd
                var t = (e.target || e.srcElement);
                var id = null;
                while (t._accId != this && id == null) {
                    if (t._accId != null) {
                        id = t._accId;
                    } else {
                        t = t.parentNode;
                    }
                }
                if (id != null) {
                    that._hdrClick(id);
                }
            }
            this.t[id] = {cell: cell};
            this.conf.total_count++;
            if (this.conf.multi_mode) {
                if (typeof(open) == "undefined") {
                    open = true;
                } // opened by default if not set
                this.cont.appendChild(cell.cell);
                cell.conf.opened = (open == true);
                if (typeof(height) == "undefined" || height == null || height == "*") {
                    if (height == "*") {
                        cell.conf.h_auto = true;
                    }
                    height = this.conf.def_height;
                } else {
                    height = Math.max(parseInt(height), 30);
                }
                // dim
                cell._setSize(this.ofs.m.left, 0, this.conf.cont_w || this._getAvailItemWidth(), cell.conf.opened ? height : cell._getHdrHeight());
                cell.cell.style.marginTop = (cell.cell == this.cont.firstChild ? this.ofs.m.first : this.ofs.m.between) + "px";
                if (open != true) {
                    cell.conf.size.h = height;
                    cell._adjustCell();
                    cell.cell.className += " dhx_cell_closed";
                }
                this._adjustOpened();
                if (this._dnd != null) {
                    this._dndAttachEvent(id);
                }
            } else {

                // closed by default or force if first node
                open = (this.conf.last_opened == null ? true : window.dhx4.s2b(open));
                var h = this._updateCellsHeight();
                // close prev already opened cell if any or reduce height
                if (this.conf.last_opened != null) {
                    if (open) {
                        this._closeItem(this.conf.last_opened, false);
                    } else {
                        var openedCell = this.t[this.conf.last_opened].cell;
                        openedCell._setSize(openedCell.conf.size.x, openedCell.conf.size.y, openedCell.conf.size.w, h);
                        openedCell = null;
                    }
                }
                this.cont.appendChild(cell.cell);
                cell.conf.opened = open;
                cell.cell.style.marginTop = String(cell.cell == this.cont.firstChild ? this.ofs.s.first : this.ofs.s.between) + "px";
                cell._setSize(this.ofs.s.left, 0, this.conf.cont_w || this._getAvailItemWidth(), open ? h : cell._getHdrHeight());
                if (open) {
                    this.conf.last_opened = id;
                } else {
                    cell.conf.size.h = h;
                    cell._adjustCell();
                    cell.cell.className += " dhx_cell_closed";
                }
            }
            cell = null;
            return this.t[id].cell;
        }
        this.removeItem = function (id) {
            if (!this.t[id]) {
                return;
            }
            if (this.conf.last_opened == id) {
                this.conf.last_opened = null;
            }
            if (this.conf.on_active_id == id) {
                this.conf.on_active_id = null;
            }
            if (this._dnd != null) {
                this._dndClearCell(id);
            }
            this.conf.total_count--;
            if (!this.conf.multi_mode && !this.t[id].cell.conf.visible) {
                this.conf.hiden_count--;
            }
            this.t[id].cell._unload();
            this.t[id].cell = null;
            this.t[id] = null;
            delete this.t[id];
            if (!this.conf.unloading) {
                if (!this.conf.multi_mode) {
                    this._updateCellsMargin();
                }
                this.setSizes();
            }
        }
        this.cells = function (id) {
            return this.t[id].cell;
        }
        this.enableMultiMode = function (yScrollMode, defaultHeight) { // disabled by default
            this.conf.multi_mode = true;
            if (!isNaN(defaultHeight)) {
                this.conf.def_height = defaultHeight;
            }
            if (yScrollMode == "auto" || yScrollMode == "scroll") {
                this.cont.style.overflowX = "hidden";
                this.cont.style.overflowY = yScrollMode;
            } else {
                this.cont.style.overflow = "visible";
            }
        }
        this.forEachItem = function (func) {
            for (var a in this.t) {
                if (typeof(func) == "function") {
                    func.apply(this, [this.t[a].cell]);
                } else {
                    if (typeof(func) == "string" && typeof(window[func]) == "function") {
                        window[func].apply(this, [this.t[a].cell]);
                    }
                }
            }
        }
        this._openItem = function (id, ef) {
            if (typeof(ef) == "undefined") {
                ef = true;
            }
            if (this.t[id].cell.conf.opened == false) {
                if (this.conf.multi_mode) {
                    this.t[id].cell._open(ef);
                } else {
                    if (this.conf.tr.prop == false) {

                        // simple open/close
                        if (this.conf.last_opened != null) {
                            this.t[this.conf.last_opened].cell._close(false);
                        }
                        this.t[id].cell._open(false);
                        this.conf.last_opened = id;
                    } else {
                        this.conf.on_active_id = id;
                        this.t[id].cell._open(ef);
                        if (this.conf.last_opened != null) {
                            this.t[this.conf.last_opened].cell._close(ef);
                        }
                        this.conf.last_opened = id;
                    }
                }
            }
        }
        this._closeItem = function (id, ef) {
            if (typeof(ef) == "undefined") {
                ef = true;
            }
            if (this.t[id].cell.conf.opened == true) {
                this.t[id].cell._close(ef);
                this.conf.last_opened = null;
            }
        }
        this._adjustOpened = function () {

            // multi_mode - only width, check v-scroll
            // single_mode - width/height
            if (this.conf.multi_mode == true) {

                // new edition
                if (this._openCache == null) {
                    var dynData = this._getDynData();
                    for (var a in dynData) {
                        this.t[a].cell.conf.size.h = Math.max(dynData[a], 0);
                        this.t[a].cell.cell.style.height = Math.max(dynData[a], 0) + "px";
                    }
                } else {
                    var inProgress = false;
                    for (var a in this._openCache) {
                        inProgress = (inProgress || this._openCache[a]);
                    }
                    if (inProgress == true) {
                        return;
                    }
                    this._openCache = this._openId = null;
                }
                var w2 = this._getAvailItemWidth();
                for (var a in this.t) {
                    var adj = true;
                    if (w2 == this.t[a].cell.conf.size.w && (this._openMode == "close" || this.t[a].cell.conf.opened == false)) {
                        adj = false;
                    }
                    if (adj) {
                        this.t[a].cell._setWidth(w2);
                    }
                }
                this._openMode = null;
            } else {
                if (this.conf.last_opened != null) {
                    var id = this.conf.last_opened;
                    this.t[id].cell._setSize(this.t[id].cell.conf.size.x, this.t[id].cell.conf.size.y, this.t[id].cell.conf.size.w, this.t[id].cell.conf.size.h);
                }
            }
        }
        this._getDynData = function (toOpen, toClose) {

            // toOpen/toClose - static_or_dyn closed cell from _open() or _close(),
            // cells shoule be included into calculations
            if (typeof(toOpen) == "undefined" || toOpen == null) {
                toOpen = {};
            }
            if (typeof(toClose) == "undefined" || toClose == null) {
                toClose = {};
            }
            var dynData = {};
            var dynCount = 0;
            var h = 0;
            var f0 = 0; // item index (visible only)
            for (var q = 0; q < this.cont.childNodes.length; q++) {
                var id = this.cont.childNodes[q]._accId;
                var t = this.t[id].cell;
                if (t.conf.visible == true) {
                    var ofs = this.ofs.m[f0 == 0 ? "first" : "between"];
                    if (toOpen[id] == true || toClose[id] == true || (t.conf.opened == true && t.conf.h_auto == true)) {
                        if (toClose[id] == true) {
                            var h0 = t._getHdrHeight();
                            dynData[id] = h0; // static cell going to opened, include to common h
                            h += h0 + ofs;
                        } else if (t.conf.h_auto == true) { // dyn cell is here, just mark, include margin only
                            dynData[id] = true;
                            h += ofs;
                            dynCount++;
                        } else if (toOpen[id] == true) {
                            dynData[id] = t.conf.size.h; // static cell going to opened, include to common h
                            h += t.conf.size.h + ofs;
                        }
                    } else {
                        h += t.cell.offsetHeight + ofs; // collapsed or static
                    }
                    f0++;
                }
                t = null;
            }
            // 2) calculate height for single h_auto cell
            // (avail_space-static_cells_height-closed_cells_height) / h_auto_cells_count
            if (dynCount > 0) {
                var hSum = this.cont.offsetHeight - h;
                var h = Math.floor(hSum / dynCount);
                for (var a in dynData) {
                    if (dynData[a] == true) {
                        if (dynCount > 1) {
                            hSum -= h;
                        } else {
                            h = hSum;
                        } // decrease main height each time, last item used all left height
                        dynData[a] = h;
                        dynCount--;
                    }
                }
            }
            return dynData;
        }
        this.setSizes = function () {
            this._adjustCont();
            if (this.conf.multi_mode == true) {
                this._adjustOpened();
            } else {
                this.conf.cont_w = null; // reset saved base width
                var h = this._updateCellsHeight();
                for (var a in this.t) {
                    if (this.t[a].cell.conf.visible == true) {
                        this.t[a].cell._setSize(this.ofs.s.left, 0, this.conf.cont_w || this._getAvailItemWidth(), this.t[a].cell.conf.opened ? h : this.t[a].cell._getHdrHeight());
                        if (this.t[a].cell.conf.opened != true) {
                            this.t[a].cell.conf.size.h = h;
                            this.t[a].cell._adjustCell();
                        }
                    }
                }
                this.conf.size_changed = true; // for cell-show, recall setSizes()
            }
            this.callEvent("_onSetSizes", []);
        }
        this.setSkin = function (skin) {
            this._setBaseSkin(skin);
            this.conf.skin = skin;
            for (var a in this.t) {
                this.t[a].cell.conf.cells_cont = null; // reset cached cells offsets
                this.t[a].cell.conf.skin = this.conf.skin;
            }
            this._applyOffsets();
            this._updateCellsMargin();
            this.setSizes();
        }
        this.setIconsPath = function (path) {
            this.conf.icons_path = path;
        }
        this._getAvailItemWidth = function () {
            //
            var p = this.ofs[(this.conf.multi_mode ? "m" : "s")];
            var w = Math.max(this.cont.clientWidth - p.left - p.right, 10);
            this.conf.cont_w = w;
            p = null;
            return w;
        }
        this._updateCellsHeight = function () {

            // single_mode only
            if (this.conf.multi_mode == true) {
                return;
            }
            var k = this.conf.total_count - this.conf.hiden_count; // visible count
            var h = this.cont.offsetHeight - this.ofs.s.last;
            if (k == 0) {
                return h;
            }
            // single item_heigth = header_height + content_height
            // i.e. base_height - (visible_count-1)*header_height
            var itemFound = false;
            for (var q = 0; q < this.cont.childNodes.length; q++) {
                if (itemFound == false) {
                    var id = this.cont.childNodes[q]._accId;
                    if (this.t[id].cell.conf.visible) {
                        h -= this.t[id].cell._getHdrHeight() * (k - 1);
                        itemFound = true;
                    }
                }
            }
            // all items except 1st have top-padding=-1, include it into cell height
            h -= (k - 1) * this.ofs.s.between + this.ofs.s.first;
            for (var a in this.t) {
                // check if item inited
                if (this.t[a].cell.conf.size != null) {
                    this.t[a].cell.conf.size.h = h;
                    this.t[a].cell._adjustCell();
                }
            }
            return h;
        }
        this._updateCellsMargin = function () {
            var f0 = 0;
            for (var q = 0; q < this.cont.childNodes.length; q++) {
                var id = this.cont.childNodes[q]._accId;
                if (this.t[id].cell.conf.visible) {
                    this.t[id].cell.cell.style.marginTop = String(this.ofs[this.conf.multi_mode ? "m" : "s"][f0++ == 0 ? "first" : "between"]) + "px";
                }
            }
        }
        this._hdrClick = function (id) {
            if (!this.conf.multi_mode && this.t[id].cell.conf.opened) {
                return;
            } // not allow click-close in single-open mode
            var opened = this.t[id].cell.conf.opened;
            if (this.callEvent("onBeforeActive", [id, (opened ? false : true)]) !== true) {
                return;
            } // doc do not have 2nd param, remove or change to true/false like for onActive
            this.conf.on_active_click = true;
            this[opened ? "_closeItem" : "_openItem"](id);
            if (this.conf.multi_mode && this.conf.tr.prop == false) {
                this._adjustOpened();
            }
        }
        this.unload = function () {
            this.conf.unloading = true;
            for (var a in this.t) {
                this.removeItem(a);
            }
            this.t = null;
            if (typeof(this._unloadDND) == "function") {
                this._unloadDND();
            }
            if (this.dhxWins) {
                this.dhxWins.unload();
                this.dhxWins = null;
            }
            this._unloadTop();
            window.dhx4._enableDataLoading(this, null, null, null, "clear");
            window.dhx4._eventable(this, "clear");
            this.ofs = this.conf = null;
            for (var a in this) {
                this[a] = null;
            }
            that = null;
        }
        this.setOffset = function (ofsBetween) { // offset "between" cells, not in doc but public in prev version
            this.ofs.s.between = ofsBetween;
            this.ofs.m.between = ofsBetween;
            this._updateCellsMargin();
            this.setSizes();
        }
        this._initObj = function (data) {
            if (data.skin != null) {
                this.setSkin(data.skin);
            }
            if (window.dhx4.s2b(data.multi_mode)) {
                this.enableMultiMode();
            }
            if (data.icons_path != null) {
                this.setIconsPath(data.icons_path);
            }
            if (data.icon_path != null) { // back compat
                this.setIconsPath(data.icon_path);
            }
            if (data.iconset != null) {
                this.conf.icons_css = (data.iconset == "awesome");
            }
            if (data.items != null) {
                for (var q = 0; q < data.items.length; q++) {
                    this.addItem(data.items[q].id, data.items[q].text, data.items[q].open, data.items[q].height, data.items[q].icon || data.items[q].img);
                }
            }
            if (window.dhx4.s2b(data.dnd) == true && typeof(this.enableDND) == "function") {
                this.enableDND();
            }
        }
        this._xmlToObj = function (data) {
            var t = {items: []};
            var root = data.getElementsByTagName("accordion")[0];
            if (root.getAttribute("skin") != null) {
                t.skin = root.getAttribute("skin");
            }
            if (root.getAttribute("mode") == "multi") {
                t.multi_mode = true;
            }
            if (root.getAttribute("multiMode") != null) {
                t.multi_mode = window.dhx4.s2b(root.getAttribute("multiMode"));
            }
            if (root.getAttribute("iconsPath") != null) {
                t.icons_path = root.getAttribute("iconsPath");
            }
            for (var q = 0; q < root.childNodes.length; q++) {
                var p = root.childNodes[q];
                if (typeof(p.tagName) != "undefined" && String(p.tagName).toLowerCase() == "cell") {
                    var k = {};
                    if (p.getAttribute("id") != null) {
                        k.id = p.getAttribute("id");
                    }
                    if (p.getAttribute("icon") != null) {
                        k.icon = p.getAttribute("icon");
                    }
                    if (p.getAttribute("height") != null) {
                        k.height = p.getAttribute("height");
                    }
                    if (p.getAttribute("open") != null) {
                        k.open = window.dhx4.s2b(p.getAttribute("open"));
                    }
                    k.text = p.firstChild.nodeValue;
                    t.items.push(k);
                }
                p = null;
            }
            return t;
        }
        window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "accordion", {struct: true});
        window.dhx4._eventable(this);
        this._callMainEvent = function (name, args) {
            return this.callEvent(name, args);
        }
        // attach/detach content improves
        this.attachEvent("onActive", function (id) {
            // open/close - editor save state/make editable
            if (id != null && this.t[id] != null && this.t[id].cell.dataObj != null && this.t[id].cell.dataType == "editor") {
                this.t[id].cell.dataObj._prepareContent(true);
            }
            // adjust progress if it was activated while cell was closed
            if (id != null && this.t[id] != null && this.t[id].cell.conf.opened == true) {
                this.t[id].cell._adjustProgress();
            }
        });
        if (typeof(window.dhtmlXWindows) == "function") {
            this.dhxWins = new dhtmlXWindows();
            this.dhxWins.setSkin(this.conf.skin);
        }
        if (apiInit != null) {
            this._initObj(apiInit);
            apiInit = null;
        }
        return this;
    }
    setIconset(name) {
        this.conf.icons_css = (name == "awesome");
    }
    enableDND() {

        if (this.conf.multi_mode == false || this._dnd != null) return;

        var that = this;

        this._dnd = {
            tr_count: 0,
            tr_items: {}
        };

        this._dndAttachEvent = function(id) {
            var t = this.t[id].cell;
            if (t.conf.dnd_inited != true) {
                if (typeof(window.addEventListener) == "function") {
                    t.cell.childNodes[t.conf.idx.hdr].addEventListener("mousedown", this._dndOnMouseDown, false);
                } else {
                    t.cell.childNodes[t.conf.idx.hdr].attachEvent("onmousedown", this._dndOnMouseDown);
                }
                t.conf.dnd_inited = true;
            }
            t = null;
        }

        this._dndDetachEvent = function(id) {
            var t = this.t[id].cell;
            if (t.conf.dnd_inited == true) {
                if (typeof(window.addEventListener) == "function") {
                    t.cell.childNodes[t.conf.idx.hdr].removeEventListener("mousedown", this._dndOnMouseDown, false);
                } else {
                    t.cell.childNodes[t.conf.idx.hdr].detachEvent("onmousedown", this._dndOnMouseDown);
                }
                t.conf.dnd_inited = false;
            }
            t = null;
        }

        this._dndOnMouseDown = function(e) {
            e = e||event;
            if (e.preventDefault) e.preventDefault(); // selection in chrome
            var t = (e.target||e.srcElement);
            while (t != null && t.parentNode != that.cont) t = t.parentNode;
            if (t != null) that._dndDragStart(e, t);
            t = null;
        }

        this._dndDragStart = function(e,t) {

            if (this._dnd.tr_waiting == true) return;

            // cell index
            var ind0 = -1;
            for (var q=0; q<t.parentNode.childNodes.length; q++) {
                if (t.parentNode.childNodes[q] == t) ind0 = q;
            }

            if (this.callEvent("onBeforeDrag",[t._accId, ind0]) !== true) return; // added in 4.2

            if (typeof(window.addEventListener) == "function") {
                document.body.addEventListener("mousemove", this._dndOnMouseMove, false);
                document.body.addEventListener("mouseup", this._dndOnMouseUp, false);
            } else {
                document.body.attachEvent("onmousemove", this._dndOnMouseMove, false);
                document.body.attachEvent("onmouseup", this._dndOnMouseUp, false);
            }

            this._dnd.dragObj = t;

            this._dnd.dy = e.clientY;

            // define index and min/max offset for dragged object
            var u = 0;

            for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
                this._dnd.dragObj.parentNode.childNodes[q]._ind = q; // recalculate indecies
                if (this._dnd.dragObj.parentNode.childNodes[q] == this._dnd.dragObj) {
                    this._dnd.dragObj._k0 = u;
                    if (q > 0) this._dnd.dragObj._k0 += this.ofs.m.between-this.ofs.m.first; // include margins for non-top cells
                    u = 0;
                } else {
                    u += this._dnd.dragObj.parentNode.childNodes[q].offsetHeight+
                        parseInt(this._dnd.dragObj.parentNode.childNodes[q].style.marginTop);
                }
            }
            this._dnd.dragObj._k1 = u;

            this._dnd.h = this._dnd.dragObj.offsetHeight;

            this._dnd.ofs = false; // check if mouse was realy moved over screen
        }

        this._dndDoDrag = function(e) {

            if (!this._dnd.dragObj) return;
            if (this._dnd.tr_waiting == true) return;

            var r = e.clientY-this._dnd.dy;

            if (this._dnd.ofs == false && Math.abs(r) > 5) {
                this._dnd.dragObj.className += " acc_cell_dragged";
                this._dnd.ofs = true;
            }

            // overlaying left/right
            if (r < 0) {
                if (r < -this._dnd.dragObj._k0) r = -this._dnd.dragObj._k0;
            } else {
                if (r > this._dnd.dragObj._k1) r = this._dnd.dragObj._k1;
            }

            this._dnd.dragObj.style.top = r+"px";

            // prev

            // get offset
            var ofs = e.clientY-this._dnd.dy;
            var s0 = 0;
            var i = 0;
            for (var q=this._dnd.dragObj._ind+1; q<=this._dnd.dragObj.parentNode.lastChild._ind; q++) {
                var w0 = this._dnd.dragObj.parentNode.childNodes[q].offsetHeight;
                if (ofs > s0+w0*2/3) i++;
                s0 += w0;
            }

            // loop through siblings
            var s = this._dnd.dragObj.nextSibling;
            var q = 0;

            while (s != null) {

                if (++q<=i && s != null) {
                    // move to left if not moved yet
                    if (!s._ontop) {
                        if (s._tm) window.clearTimeout(s._tm);
                        this._dndAnim(s, false, parseInt(s.style.top||0), -this._dnd.h-this.ofs.m.between); // margin-top always "between", index here will never equal 0
                        s._ontop = true;
                    }
                } else {
                    // move to right (to orig position) if moved to left
                    if (s._ontop) {
                        if (s._tm) window.clearTimeout(s._tm);
                        this._dndAnim(s, true, parseInt(s.style.top||0), 0);
                        s._ontop = false;
                    }
                }

                s = s.nextSibling;
            }

            // next

            // get offset
            var ofs = this._dnd.dy-e.clientY;
            var s0 = 0;
            var i = 0;
            for (var q=this._dnd.dragObj._ind-1; q>=this._dnd.dragObj.parentNode.firstChild._ind; q--) {
                var w0 = this._dnd.dragObj.parentNode.childNodes[q].offsetHeight;
                if (ofs > s0+w0*2/3) i++;
                s0 += w0;
            }

            // loop through siblings
            var s = this._dnd.dragObj.previousSibling;
            var q = 0;

            while (s != null) {

                if (++q<=i && s != null) {
                    if (!s._onbottom) {
                        if (s._tm) window.clearTimeout(s._tm);
                        this._dndAnim(s, true, parseInt(s.style.top||0), this._dnd.h+this.ofs.m.between);
                        s._onbottom = true;
                    }
                } else {
                    if (s._onbottom) {
                        if (s._tm) window.clearTimeout(s._tm);
                        this._dndAnim(s, false, parseInt(s.style.top), 0);
                        s._onbottom = false;
                    }
                }

                s = s.previousSibling;
            }

        }

        this._dndDragStop = function(e, force) {

            if (force) {
                // console.log("tr ended, fix drop");
            } else {
                if (this._dnd.tr_count > 0) {
                    this._dnd.tr_waiting = true;
                    // console.log("still moving", this._dnd.tr_count);
                    return;
                }
            }

            if (!this._dnd.dragObj) return;

            this._dnd.dragObj.className = String(this._dnd.dragObj.className).replace(/\s{0,}acc_cell_dragged/gi,"");
            this._dnd.dragObj.style.top = "0px";

            var p = false;

            for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
                var s = this._dnd.dragObj.parentNode.childNodes[q];

                if (s != this._dnd.dragObj) {
                    if (s._tm) window.clearTimeout(s._tm);
                    s.style.top = "0px";
                    if (s._ontop && ((s.nextSibling != null && s.nextSibling._ontop != true) || !s.nextSibling)) {
                        p = (s.nextSibling||null);
                    }
                    if (s._onbottom && ((s.previousSibling != null && s.previousSibling._onbottom != true) || !s.previousSibling)) {
                        p = s;
                    }
                }
                s = null;
            }
            for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
                this._dnd.dragObj.parentNode.childNodes[q]._ontop = null;
                this._dnd.dragObj.parentNode.childNodes[q]._onbottom = null;
            }

            if (p !== false) {
                if (p == null) {
                    this._dnd.dragObj.parentNode.appendChild(this._dnd.dragObj);
                } else {
                    this._dnd.dragObj.parentNode.insertBefore(this._dnd.dragObj, p);
                }
            }

            var id = this._dnd.dragObj._accId;
            var ind0 = this._dnd.dragObj._ind;
            var ind1 = ind0;
            for (var q=0; q<this._dnd.dragObj.parentNode.childNodes.length; q++) {
                if (this._dnd.dragObj.parentNode.childNodes[q] == this._dnd.dragObj) ind1 = q;
            }

            this._dnd.dragObj = null;
            this._dnd.tr_waiting = false;

            this._updateCellsMargin();
            if (ind0 != ind1) {
                this.setSizes();
                this.callEvent("onDrop", [id, ind0, ind1]);
            }

            if (typeof(window.addEventListener) == "function") {
                document.body.removeEventListener("mousemove", this._dndOnMouseMove, false);
                document.body.removeEventListener("mouseup", this._dndOnMouseUp, false);
            } else {
                document.body.detachEvent("onmousemove", this._dndOnMouseMove, false);
                document.body.detachEvent("onmouseup", this._dndOnMouseUp, false);
            }
        }

        this._dndAnim = function(obj, dir, f, t) {

            if (this.conf.tr.prop != false) {

                if (!obj._dnd_ev) {
                    obj._dnd_ev = true;
                    obj._dnd_tr_prop = this.conf.tr.prop;
                    obj.addEventListener(this.conf.tr.ev, this._dndOnTrEnd, false);
                }

                if (this._dnd.tr_items[obj._accId] != true) {
                    this._dnd.tr_items[obj._accId] = true;
                    this._dnd.tr_count++;
                }

                obj.style[this.conf.tr.prop] = this.conf.tr.dnd_top;
                obj.style.top = t+"px";
                return;
            }

            var stop = false;
            if (dir) {
                f += 5;
                if (f >= t) { f = t; stop = true; }
            } else {
                f -= 5;
                if (f <= t) { f = t; stop = true; }
            }
            obj.style.top = f+"px";
            if (obj._tm) window.clearTimeout(obj._tm);
            if (!stop) {
                obj._tm = window.setTimeout(function(){that._dndAnim(obj, dir, f, t);},5);
            } else {
                obj._tm = null;
            }

        }

        this._dndOnTrEnd = function(ev) {
            if (ev.stopPropagation) ev.stopPropagation();
            if (ev.propertyName == "top") {
                // clear cache
                if (that._dnd.tr_items[this._accId] == true) {
                    that._dnd.tr_count--;
                    that._dnd.tr_items[this._accId] = false;
                }
                // remove prop
                this.style[this._dnd_tr_prop] = "";
                //
                if (that._dnd.tr_count == 0 && that._dnd.tr_waiting == true) {
                    that._dndDragStop(null, true);
                }
            }
        }

        this._dndOnMouseMove = function(e) {
            that._dndDoDrag(e||event);
        }

        this._dndOnMouseUp = function(e) {
            that._dndDragStop(e||event);
        }

        this._dndClearCell = function(id) {
            if (this.t[id].cell.cell._dnd_ev) this.t[id].cell.cell.addEventListener(this.conf.tr.ev, this._dndOnTrEnd, false);
            this._dndDetachEvent(id);
        }

        this._unloadDND = function() {

            // functions
            for (var a in this) {
                if (String(a).indexOf("_dnd") == 0 && typeof(this[a]) == "function") this[a] = null;
            }

            // cell-clear will called from removeItem()
            this._dnd = null;
            that = null;
        }

        // update cells
        for (var a in this.t) this._dndAttachEvent(a);

    }
}
class dhtmlXAccordionCell extends dhtmlXCellObject {
    constructor(id, acc) {
        super(id, "_acc")
        this.acc = acc;
        this.conf.visible = true;
        this.conf.docked = true;
        this.attachEvent("_onCellUnload", function () {
            this._trDetachEv();
            this._unloadDocking();
            this.acc = null;
            this.cell._accObj = null;
            this.cell.childNodes[this.conf.idx.hdr].onselectstart = null;
            this.cell.childNodes[this.conf.idx.hdr].onclick = null;
            this._initHeader = null;
            this._getHdrHeight = null;
            this._setWidth = null;
            this._adjustCell = null;
            this._open = null;
            this._close = null;
            this._isOpened = null;
            this._trInitEv = null;
            this._trAttachEv = null;
            this._trDetachEv = null;
            this._trOnEnd = null;
            this._onActiveCall = null;
            this.setText = null;
            this.getText = null;
            this.setIcon = null;
            this.clearIcon = null;
            this.show = null;
            this.hide = null;
            this.isVisible = null;
            this.setHeight = null;
            this.moveOnTop = null;
        });
        // fix editor contentEditable while dnd if attached
        this.acc.attachEvent("onBeforeDrag", function (id) {
            if (this.t[id].cell.dataObj != null && this.t[id].cell.dataType == "editor") {
                if (this.conf.editor_data == null) {
                    this.conf.editor_data = {};
                }
                this.conf.editor_data[id] = this.t[id].cell.dataObj.getContent();
            }
            for (var a in this.t) {
                this.t[a].cell._showCellCover();
            }
            return true;
        });
        this.acc.attachEvent("onDrop", function (id) {
            if (this.t[id].cell.dataObj != null && this.t[id].cell.dataType == "editor") {
                this.t[id].cell.dataObj._prepareContent(true)
                if (this.conf.editor_data != null && this.conf.editor_data[id] != null) {
                    this.t[id].cell.dataObj.setContent(this.conf.editor_data[id]);
                    this.conf.editor_data[id] = null;
                }
            }
            for (var a in this.t) {
                this.t[a].cell._hideCellCover();
            }
        });
        this.attachEvent("_onContentLoaded", function () {
            this.acc._callMainEvent("onContentLoaded", arguments);
        });
        this.attachEvent("_onBeforeContentAttach", function (dataType) {
            if (dataType == "sidebar" && this.conf.skin != "dhx_skyblue") {
                this._hideBorders();
            }
        });
        // init header
        this._initHeader();
        // open/close, check trans-effects
        this.conf.tr = {};
        for (var a in this.acc.conf.tr) {
            this.conf.tr[a] = this.acc.conf.tr[a];
        }
        if (this.conf.tr.prop != false) {
            this.attachEvent("_onIdxUpdated", function () {
                // if cell hidden - update opacity for menu/toolbar/status attached
                this._cellSetOpacity((this.conf.opened ? "open" : "close"), false);
            });
        }
        // open/close
        this.open = function (callEvent) {
            if (window.dhx4.s2b(callEvent) == true) {
                this.acc.conf.on_active_click = true
            }
            this.acc._openItem(this._idd);
        }
        this.close = function (callEvent) {
            if (window.dhx4.s2b(callEvent) == true) {
                this.acc.conf.on_active_click = true
            }
            this.acc._closeItem(this._idd);
        }
        // misc
        this._setWidth = function (w) {
            if (w != this.conf.size.w) {
                this.conf.size.w = w;
                this.cell.style.width = w + "px";
            }
            this._adjustCell();
        }
        this._adjustCell = function () {
            this._adjustCont();
            if (this.dataObj != null && typeof(this.dataObj.setSizes) == "function") {
                this.dataObj.setSizes();
            }
        }
        this._initDocking();
        return this;
    }
    _initHeader() {
        var t = document.createElement("DIV");
        t.className = "dhx_cell_hdr";
        t.innerHTML = "<div class='dhx_cell_hdr_text'></div>" + "<div class='dhx_cell_hdr_arrow'></div>";
        this.cell.insertBefore(t, this.cell.childNodes[this.conf.idx.cont]);
        t = null;
        // include into content top offset calculation
        this.conf.ofs_nodes.t._getHdrHeight = "func";
        // show/hide
        this.conf.hdr = {visible: true};
        // include into index
        this.conf.idx_data.hdr = "dhx_cell_hdr";
        this._updateIdx();
    }
    _getHdrHeight() {
        var t = this.cell.childNodes[this.conf.idx.hdr];
        var h = t.offsetHeight || t.offsetHeight; // fix for ie8 - sometimes on 1st check it gives 0
        t = null;
        return h;
    }
    showHeader() {
        if (this.conf.hdr.visible == true) {
            return;
        }
        this.conf.hdr.visible = true;
        this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr";
        this._adjustCont(this._idd);
    }
    hideHeader() {
        if (this.conf.hdr.visible != true) {
            return;
        }
        this.conf.hdr.visible = false;
        this.cell.childNodes[this.conf.idx.hdr].className = "dhx_cell_hdr dhx_cell_hdr_hidden";
        this._adjustCont(this._idd);
    }
    isHeaderVisible() {
        return (this.conf.hdr.visible == true);
    }
    setText(text) {
        this.conf.text = text;
        var t = this.cell.childNodes[this.conf.idx.hdr];
        t.childNodes[(t.firstChild.className == "dhx_cell_hdr_icon" ? 1 : 0)].innerHTML = "<span>" + text + "</span>";
        t = null;
    }
    getText() {
        return this.conf.text;
    }
    setIcon(icon) {
        var t = this.cell.childNodes[this.conf.idx.hdr];
        if (this.acc.conf.icons_css == true) {
            if ((t.firstChild.tagName || "").toLowerCase() != "i") {
                t.firstChild.className += " dhx_cell_hdr_icon";
                var i = document.createElement("I");
                t.insertBefore(i, t.firstChild);
                i = null;
            }
            t.firstChild.className = icon;
        } else {
            if (t.firstChild.className != "dhx_cell_hdr_icon") {
                t.firstChild.className += " dhx_cell_hdr_icon";
                var k = document.createElement("IMG");
                k.className = "dhx_cell_hdr_icon";
                t.insertBefore(k, t.firstChild);
                k = null;
            }
            t.firstChild.src = this.acc.conf.icons_path + icon;
        }
        t = null;
    }
    clearIcon() {
        var t = this.cell.childNodes[this.conf.idx.hdr];
        if (t.firstChild.className == "dhx_cell_hdr_icon" || (t.firstChild.tagName || "").toLowerCase() == "i") {
            t.removeChild(t.firstChild);
            t.firstChild.className = String(t.firstChild.className).replace(/\s{1,}dhx_cell_hdr_icon/gi, "");
        }
        t = null;
    }
    _open(ef) {
        var dynData = {};
        if (this.acc.conf.multi_mode) {
            var toOpen = {};
            toOpen[this._idd] = true;
            dynData = this.acc._getDynData(toOpen);
            this.acc._openId = this._idd;
            this.acc._openCache = {};
            this.acc._openMode = "open";
        } else {

            // h_auto cells not found, simple change height of current cell
            dynData[this._idd] = this.conf.size.h;
        }
        for (var a in dynData) {
            if (this.acc._openCache != null) {
                this.acc._openCache[a] = true;
            }
            var t = this.acc.t[a].cell;
            t.cell.className = String(t.cell.className).replace(/\s{1,}dhx_cell_closed/gi, "");
            t.conf.opened = true;
            t._trInitEv("open", ef);
            t.conf.size.h = dynData[a];
            t.cell.style.height = t.conf.size.h + "px"; // restore last height
            t = null;
        }
        // effect is not enabled, adjust cells after resize
        if (this.conf.tr.prop == false) {
            this.acc._openId = this.acc._openCache = this.acc._openMode = null;
            this._onActiveCall(true);
        }
    }
    _close(ef) {
        var dynData = {};
        if (this.acc.conf.multi_mode) {
            var toClose = {};
            toClose[this._idd] = true;
            dynData = this.acc._getDynData(null, toClose);
            this.acc._openId = this._idd;
            this.acc._openCache = {};
            this.acc._openMode = "close";
        } else {
            dynData[this._idd] = this._getHdrHeight();
        }
        for (var a in dynData) {
            var t = this.acc.t[a].cell;
            if (this.acc._openCache != null) {
                this.acc._openCache[a] = true;
            }
            if (a == this._idd) {
                t.cell.className += " dhx_cell_closed";
                t.conf.opened = false;
                t._trInitEv("close", ef);
            } else {
                // keep opened
                t.conf.size.h = dynData[a];
                t._adjustCell();
                t._trInitEv("open", ef);
            }
            t.cell.style.height = dynData[a] + "px"; // set height as hdr height
            t = null;
        }
        if (this.conf.tr.prop == false) {
            this.acc._openId = this.acc._openCache = this.acc._openMode = null;
            this._onActiveCall(false);
        }
    }
    isOpened() {
        return (this.conf.opened == true);
    }
    _trInitEv(mode, ef) {
        if (this.conf.tr.prop == false) {
            return;
        }
        this._trAttachEv();
        if (!this.cell._accObj) {
            this.cell._accObj = this.acc;
        } // acc obj for transion end
        // open with effect (usualy by click, w/o usualy on init stage)
        if (ef) {
            this.cell.style[this.conf.tr.prop] = this.conf.tr["height_" + mode];
        }
        // opacity
        this._cellSetOpacity(mode, ef);
    }
    _trAttachEv() {
        if (!this.conf.tr.ev_attached) {
            this.cell._trProp = this.conf.tr.prop;
            this.cell.addEventListener(this.conf.tr.ev, this._trOnEnd, false);
            this.conf.tr.ev_attached = true;
        }
    }
    _trDetachEv() {
        if (this.conf.tr.ev_attached) {
            this.cell.addEventListener(this.conf.tr.ev, this._trOnEnd, false);
            this.conf.tr.ev_attached = false;
        }
    }
    _trOnEnd(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        }
        if (ev.propertyName == "height" && this._accObj != null) {
            this.style[this._trProp] = "";
            if (this._accObj.conf.multi_mode) {
                if (this._accObj._openCache != null) {
                    this._accObj._openCache[this._accId] = false;
                }
                this._accObj._adjustOpened();
            }
            if (this._accObj.conf.on_active_click == true) {
                if (this._accObj.conf.multi_mode) {
                    this._accObj._callMainEvent("onActive", [this._accId, this._accObj.t[this._accId].cell.conf.opened]);
                    this._accObj.conf.on_active_click = false;
                } else {
                    if (this._accObj.conf.on_active_id != null) {
                        // trigger only open-state events for single-cell mode
                        this._accObj._callMainEvent("onActive", [this._accObj.conf.on_active_id, true]);
                    }
                    this._accObj.conf.on_active_id = null;
                    this._accObj.conf.on_active_click = false;
                }
            }
            this._accObj = null;
        }
    }
    _cellSetOpacity(mode, ef) {
        // mode - "open"/"close"
        for (var a in this.conf.idx) {
            if ({
                    hdr: true,
                    pr1: true,
                    pr2: true,
                    cover: true
                }[a] != true) { // skip hdr and progress
                if (ef) {
                    this.cell.childNodes[this.conf.idx[a]].style[this.conf.tr.prop] = this.conf.tr["op_" + mode];
                }
                this.cell.childNodes[this.conf.idx[a]].style.opacity = this.conf.tr["op_v_" + mode];
            }
        }
    }
    _onActiveCall(mode) {
        if (this.acc.conf.on_active_click == false) {
            return;
        }
        if (this.acc.conf.multi_mode == true) {
            this.acc._callMainEvent("onActive", [this._idd, this.conf.opened]);
            this.acc.conf.on_active_click = false;
        } else {
            // single_mode, call only for opened
            if (mode == true) {
                this.acc._callMainEvent("onActive", [this._idd, true]);
                this.acc.conf.on_active_click = false;
            }
        }
    }
    show() {
        if (this.conf.visible) {
            return;
        }
        if (this.conf.docked == false) { // if cell is undocked - show after dock
            this.dock();
            return;
        }
        this.cell.style.display = "";
        this.conf.visible = true;
        if (!this.acc.conf.multi_mode) {
            this.acc.conf.hiden_count--;
            this.acc._updateCellsHeight();
            this.acc._updateCellsMargin();
        }
        if (this.acc.conf.size_changed) {
            this.acc.setSizes();
            this.acc.conf.size_changed = false;
        } else {
            this.acc._adjustOpened();
        }
    }
    hide() {
        if (!this.conf.visible) {
            return;
        }
        if (!this.acc.conf.multi_mode && this.conf.opened) { // close before hide if any
            this._close(false);
            this.acc.conf.last_opened = null;
        }
        this.cell.style.display = "none";
        this.conf.visible = false;
        if (!this.acc.conf.multi_mode) {
            this.acc.conf.hiden_count++;
            this.acc._updateCellsHeight();
            this.acc._updateCellsMargin();
        }
        this.acc._adjustOpened();
    }
    isVisible() {
        return (this.conf.visible == true);
    }
    setHeight(h) { // multi_mode only
        if (!this.acc.conf.multi_mode) {
            return;
        }
        if (h == "*") {
            this.conf.h_auto = true;
        } else {
            this.conf.h_auto = false;
            this.conf.size.h = h;
        }
        if (this.conf.opened) {
            if (h != "*") {
                this.cell.style.height = h + "px";
            }
            this.acc._adjustOpened();
        }
    }
    moveOnTop() {
        if (this.cell.parentNode.firstChild == this.cell) {
            return;
        } // item moved
        this.cell.parentNode.insertBefore(this.cell, this.cell.parentNode.firstChild);
        this.acc._updateCellsMargin();
    }
    _initDocking() {
        var that = this;
        this.dock = function () {
            if (this.acc.dhxWins == null || this.conf.docked == true) {
                return;
            }
            var w1 = this.acc.dhxWins.window(this._idd);
            w1.close();
            // move content
            this._attachFromCell(w1);
            this.conf.docked = true;
            this.show();
            if (this.conf.dock_opened) {
                this.open();
            }
            w1 = null;
            this.acc._callMainEvent("onDock", [this._idd]);
        };
        this.undock = function (x, y, w, h) {
            if (this.acc.dhxWins == null || this.conf.docked == false) {
                return;
            }
            this.conf.dock_opened = this.conf.opened;
            if (this.acc.dhxWins.window(this._idd) != null) {
                var w1 = this.acc.dhxWins.window(this._idd);
                w1.show();
            } else {
                if (x == null) {
                    x = 20;
                }
                if (y == null) {
                    y = 20;
                }
                if (w == null) {
                    w = 320;
                }
                if (h == null) {
                    h = 200;
                }
                var w1 = this.acc.dhxWins.createWindow(this._idd, x, y, w, h);
                w1.button("close").hide();
                // dock button
                w1.addUserButton("dock", 99, "Dock");
                w1.button("dock").show();
                w1.button("dock").attachEvent("onClick", this._doOnDockClick);
                // text update only first time
                w1.setText(this.getText());
                // closeing
                w1.attachEvent("onClose", this._doOnDockWinClose);
            }
            this.conf.docked = false;
            this.hide();
            // move content
            w1._attachFromCell(this);
            w1 = null;
            this.acc._callMainEvent("onUnDock", [this._idd]);
        }
        this._doOnDockClick = function () {
            that.dock();
        }
        this._doOnDockWinClose = function (win) {
            win.hide();
            return false;
        }
        this._unloadDocking = function () {
            that = null;
        }
    }
}

dhtmlXCellObject.prototype.attachAccordion = function (conf) {
    this.callEvent("_onBeforeContentAttach", ["acc"]);
    var obj = document.createElement("DIV");
    obj.style.width = "100%";
    obj.style.height = "100%";
    obj.style.position = "relative";
    this._attachObject(obj);
    if (typeof(conf) == "undefined") {
        conf = {};
    }
    if (typeof(conf.skin) == "undefined") {
        conf.skin = this.conf.skin;
    }
    conf.parent = obj;
    if (typeof(window.dhtmlXAccordionCell) == "function" && this instanceof window.dhtmlXAccordionCell) {
        if (this.conf.skin == "material") {
            obj._ofs = {
                t: -1,
                r: -1,
                b: -1,
                l: -1
            }; // attach acc to acc
        } else {
            obj._ofs = {
                s: {first: -1},
                m: {first: 4}
            }
        }
    }
    if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell) {
        if (this.conf.skin == "dhx_skyblue" || this.conf.skin == "material") {
            obj._ofs = {
                t: -1,
                r: -1,
                b: -1,
                l: -1
            };
        }
    }
    if (typeof(window.dhtmlXSideBarCell) == "function" && this instanceof window.dhtmlXSideBarCell) {
        if (this.conf.skin == "dhx_web") {
            obj._ofs = {};
            if (this.sidebar.conf.autohide != true) {
                obj._ofs.l = 2;
            }
            if (this.sidebar.conf.header == true) {
                obj._ofs.t = 3;
            } // default acc 'betweeb' conf for both single/multi modes for web skin
        } else {
            obj._ofs = {l: -1};
            if (this.conf.skin == "dhx_terrace") {
                if (this.sidebar.conf.autohide == true) {
                    obj._ofs.l = 0;
                }
                if (this.sidebar.conf.header == true) {
                    obj._ofs.t = -1;
                }
            }
        }
    }
    if (typeof(window.dhtmlXCarouselCell) == "function" && this instanceof window.dhtmlXCarouselCell) {
        this._hideBorders();
    }
    this.dataType = "acc";
    this.dataObj = new dhtmlXAccordion(conf);
    conf.parent = null;
    obj = conf = null;
    this.callEvent("_onContentAttach", []);
    return this.dataObj;
}

